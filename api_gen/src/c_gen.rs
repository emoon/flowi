use crate::api_parser::*;
///
///
use std::fs::File;
use std::io;
use std::io::{BufWriter, Write};

///
/// Base header for all header files
///
static HEADER: &str = "
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is auto-generated by api_gen. DO NOT EDIT!
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once\n
#include <stdint.h>
#include <stdbool.h>\n

#ifdef __cplusplus
extern \"C\" {
#endif\n";

///
/// Footer that is generated at the end of the the file
///
static FOOTER: &str = "
#ifdef __cplusplus
}
#endif\n";

static C_API_SUFIX_STRUCTS_ENUMS: &str = "Fl";
static C_API_SUFIX_FUNCS: &str = "fl";

pub struct Cgen;

impl Cgen {
    fn generate_enum<W: Write>(f: &mut W, enum_def: &Enum) -> io::Result<()> {
        if !enum_def.doc_comments.is_empty() {
            writeln!(f, "// {}", &enum_def.doc_comments)?;
        }

        writeln!(f, "typedef enum {}{} {{", C_API_SUFIX_STRUCTS_ENUMS, enum_def.name)?;

        for entry in &enum_def.entries {
            if !entry.doc_comments.is_empty() {
                writeln!(f, "    // {}", &entry.doc_comments)?;
            }

            writeln!(f, "    {}{}_{} = {},", C_API_SUFIX_STRUCTS_ENUMS, enum_def.name, &entry.name, entry.value)?;
        }

        writeln!(f, "}} {}{};", C_API_SUFIX_STRUCTS_ENUMS, enum_def.name)
    }

    pub fn generate(filename: &str, api_def: &ApiDef) -> io::Result<()> {
        let mut f = BufWriter::new(File::create(filename)?);
        writeln!(f, "{}", HEADER)?;

        for enum_def in &api_def.enums {
            Self::generate_enum(&mut f, &enum_def)?;
        }

        writeln!(f, "{}", FOOTER)
    }
}


