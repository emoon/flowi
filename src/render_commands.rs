// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::manual::{get_last_error, Color, FlString, Result};

#[allow(unused_imports)]
use bitflags::bitflags;

/// Texture format specificed when using [CreateTexture] command
#[repr(C)]
#[derive(Debug)]
pub enum TextureFormat {
    /// Single byte texture in linear format
    R8Linear = 0,
    /// 3 byte R,G,B format (sRGB)
    Rgb8Srgb = 1,
    /// 3 byte R,G,B format (LINEAR)
    Rgb8Linear = 2,
    /// 4 byte R,G,B,A format (sRGB)
    Rgba8Srgb = 3,
    /// 4 byte R,G,B,A format (LINEAR)
    Rgba8Linear = 4,
    /// 16-bit single format. This will mostly be used for temporary things such as blurs that requires more
    /// than one pass rendering. i16 or f16 will allow better accuracy, but R8_LINEAR can be used in worst case
    /// in case the rendering backend doesn't support this format
    I16OrF16Linear = 5,
}

/// Used when specifying rect updates
#[repr(C)]
#[derive(Debug)]
pub struct RenderRect {
    pub x0: i32,
    pub y0: i32,
    pub x1: i32,
    pub y1: i32,
}

/// Vertex layout for textured triangles
#[repr(C)]
#[derive(Debug)]
pub struct VertPosUvColor {
    pub x: f32,
    pub y: f32,
    pub u: u16,
    pub v: u16,
    pub color: u32,
}

/// Vertex layout for solid triangles
#[repr(C)]
#[derive(Debug)]
pub struct VertPosColor {
    pub x: f32,
    pub y: f32,
    pub color: u32,
}

/// Used for rendering triangles with a texture.
#[repr(C)]
#[derive(Debug)]
pub struct TexturedTriangles {
    /// Offset into the index buffer
    pub offset: u32,
    /// Vertices for the command
    pub vertex_buffer: *const VertPosUvColor,
    vertex_buffer_size: u32,
    /// Index buffer for the command
    pub index_buffer: *const u16,
    index_buffer_size: u32,
    /// Texture id used for the command
    pub texture_id: u32,
}

#[repr(C)]
#[derive(Debug)]
pub struct SolidTriangles {
    /// Offset into the index buffer
    pub offset: u32,
    /// Vertices for the command
    pub vertex_buffer: *const VertPosColor,
    vertex_buffer_size: u32,
    /// Index buffer for the command
    pub index_buffer: *const u16,
    index_buffer_size: u32,
}

#[repr(C)]
#[derive(Debug)]
pub struct CreateTexture {
    /// Data upload (can be NULL if data is uploaded later)
    pub data: *const u8,
    data_size: u32,
    /// This is the id that will later be used when refering to the texture
    pub id: u16,
    /// See [TextureFormat] for the type
    pub format: u16,
    /// width of the texture
    pub width: u16,
    /// height of the texture
    pub height: u16,
}

/// This is used to update an existing texture with some data. This usually happens when a new image/glyph/etc
/// needs to be displayed but isn't present in a texture yet
#[repr(C)]
#[derive(Debug)]
pub struct UpdateTexture {
    /// Data to upload
    pub data: *const u8,
    data_size: u32,
    /// area to update
    pub rect: RenderRect,
    /// Texture to update
    pub texture_id: u16,
}

/// Used when restricting an area for rendering. How this is to be implemented depends onthe GPU
/// API, but for OpenGL this corresponts to https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glScissor.xml
#[repr(C)]
#[derive(Debug)]
pub struct ScissorRect {
    /// Area restricted for rendering
    pub rect: RenderRect,
}
