// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::manual::{get_last_error, Color, FlString, Result};

#[allow(unused_imports)]
use bitflags::bitflags;

#[allow(unused_imports)]
use crate::math_data::*;

#[allow(unused_imports)]
use crate::image::*;

#[repr(C)]
pub struct ButtonFfiApi {
    pub(crate) data: *const core::ffi::c_void,
    regular: unsafe extern "C" fn(data: *const core::ffi::c_void, label: FlString) -> bool,
    regular_size:
        unsafe extern "C" fn(data: *const core::ffi::c_void, label: FlString, size: Vec2) -> bool,
    small: unsafe extern "C" fn(data: *const core::ffi::c_void, label: FlString) -> bool,
    invisible: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        label: FlString,
        size: Vec2,
        flags: ButtonFlags,
    ) -> bool,
    check_box: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        label: FlString,
        state: *mut bool,
    ) -> bool,
    radio:
        unsafe extern "C" fn(data: *const core::ffi::c_void, label: FlString, state: bool) -> bool,
    bullet: unsafe extern "C" fn(data: *const core::ffi::c_void),
    image_with_text:
        unsafe extern "C" fn(data: *const core::ffi::c_void, image: u64, label: FlString) -> bool,
}

bitflags! {
#[repr(C)]
pub struct ButtonFlags : u32 {
    /// Default flags
    const NONE = 0;
    /// React on left mouse button (default)
    const MOUSE_BUTTON_LEFT = 1 << 0;
    /// React on right mouse button
    const MOUSE_BUTTON_RIGHT = 1 << 1;
    /// React on center mouse button
    const MOUSE_BUTTON_MIDDLED = 1 << 2;
}}

#[repr(C)]
#[derive(Debug)]
pub struct Button {
    _dummy: u32,
}

#[repr(C)]
pub struct ButtonApi {
    pub api: *const ButtonFfiApi,
}

impl ButtonApi {
    /// Show a regular push button
    pub fn regular(&self, label: &str) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.regular)(_api.data, FlString::new(label));
            ret_val
        }
    }

    /// Show a regular push button with a specific size
    pub fn regular_size(&self, label: &str, size: Vec2) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.regular_size)(_api.data, FlString::new(label), size);
            ret_val
        }
    }

    /// Show a regular push button without any frame padding.
    pub fn small(&self, label: &str) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.small)(_api.data, FlString::new(label));
            ret_val
        }
    }

    /// Invisible button that allows custom using drawing, but still acts like a button.
    pub fn invisible(&self, label: &str, size: Vec2, flags: ButtonFlags) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.invisible)(_api.data, FlString::new(label), size, flags);
            ret_val
        }
    }

    /// Button with a check box state
    pub fn check_box(&self, label: &str, state: &mut bool) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.check_box)(_api.data, FlString::new(label), state as _);
            ret_val
        }
    }

    /// Radio button
    pub fn radio(&self, label: &str, state: bool) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.radio)(_api.data, FlString::new(label), state);
            ret_val
        }
    }

    /// TODO: Document
    pub fn bullet(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.bullet)(_api.data);
        }
    }

    /// TODO: Document
    pub fn image_with_text(&self, image: Image, label: &str) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.image_with_text)(_api.data, image.handle, FlString::new(label));
            ret_val
        }
    }
}
