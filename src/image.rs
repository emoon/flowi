// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::manual::{get_last_error, Color, FlString, Result};

#[allow(unused_imports)]
use bitflags::bitflags;

#[repr(C)]
pub struct ImageFfiApi {
    pub(crate) data: *const core::ffi::c_void,
    create_from_file:
        unsafe extern "C" fn(data: *const core::ffi::c_void, filename: FlString) -> u64,
    create_from_memory: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        name: FlString,
        data: *const u8,
        data_size: u32,
    ) -> u64,
    create_svg_from_file: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        filename: FlString,
        target_width: u32,
        flags: SvgFlags,
    ) -> u64,
    create_svg_from_memory: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        name: FlString,
        data: *const u8,
        data_size: u32,
        target_width: u32,
        flags: SvgFlags,
    ) -> u64,
    get_info: unsafe extern "C" fn(data: *const core::ffi::c_void, image: u64) -> *const ImageInfo,
}

#[repr(C)]
#[derive(Debug)]
pub enum SvgFlags {
    /// Render the SVG image using RGBA format
    Rgba = 0,
    /// Render the SVG image using Alpha only
    Alpha = 1,
}

#[repr(C)]
#[derive(Debug)]
pub struct ImageInfo {
    /// width of the image
    pub width: u32,
    /// height of the Image
    pub height: u32,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Image {
    pub handle: u64,
}

#[repr(C)]
pub struct ImageApi {
    pub api: *const ImageFfiApi,
}

impl ImageApi {
    /// Load image from file. Supported formats are:
    /// JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
    /// PNG 1/2/4/8/16-bit-per-channel
    /// TGA
    /// BMP non-1bpp, non-RLE
    /// PSD (composited view only, no extra channels, 8/16 bit-per-channel)
    /// GIF
    /// HDR (radiance rgbE format)
    /// PIC (Softimage PIC)
    /// PNM (PPM and PGM binary only)
    pub fn create_from_file(&self, filename: &str) -> Result<Image> {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.create_from_file)(_api.data, FlString::new(filename));
            if ret_val == 0 {
                Err(get_last_error())
            } else {
                Ok(Image { handle: ret_val })
            }
        }
    }

    /// Load image from memory. Supported formats are:
    /// JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
    /// PNG 1/2/4/8/16-bit-per-channel
    /// TGA
    /// BMP non-1bpp, non-RLE
    /// PSD (composited view only, no extra channels, 8/16 bit-per-channel)
    /// GIF
    /// HDR (radiance rgbE format)
    /// PIC (Softimage PIC)
    /// PNM (PPM and PGM binary only)
    pub fn create_from_memory(&self, name: &str, data: &[u8]) -> Result<Image> {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.create_from_memory)(
                _api.data,
                FlString::new(name),
                data.as_ptr(),
                data.len() as _,
            );
            if ret_val == 0 {
                Err(get_last_error())
            } else {
                Ok(Image { handle: ret_val })
            }
        }
    }

    /// Load SVG from file
    pub fn create_svg_from_file(
        &self,
        filename: &str,
        target_width: u32,
        flags: SvgFlags,
    ) -> Result<Image> {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.create_svg_from_file)(
                _api.data,
                FlString::new(filename),
                target_width,
                flags,
            );
            if ret_val == 0 {
                Err(get_last_error())
            } else {
                Ok(Image { handle: ret_val })
            }
        }
    }

    /// Load SVG from memory
    pub fn create_svg_from_memory(
        &self,
        name: &str,
        data: &[u8],
        target_width: u32,
        flags: SvgFlags,
    ) -> Result<Image> {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.create_svg_from_memory)(
                _api.data,
                FlString::new(name),
                data.as_ptr(),
                data.len() as _,
                target_width,
                flags,
            );
            if ret_val == 0 {
                Err(get_last_error())
            } else {
                Ok(Image { handle: ret_val })
            }
        }
    }

    /// Get data amout the image
    pub fn get_info<'a>(&self, image: Image) -> Result<&'a ImageInfo> {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_info)(_api.data, image.handle);
            if ret_val.is_null() {
                Err(get_last_error())
            } else {
                Ok(&*ret_val)
            }
        }
    }
}
