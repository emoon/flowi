// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::manual::{get_last_error, Color, FlString, Result};

#[allow(unused_imports)]
use bitflags::bitflags;

#[repr(C)]
pub struct MenuFfiApi {
    pub(crate) data: *const core::ffi::c_void,
    begin_bar: unsafe extern "C" fn(data: *const core::ffi::c_void) -> bool,
    end_bar: unsafe extern "C" fn(data: *const core::ffi::c_void),
    begin_main_bar: unsafe extern "C" fn(data: *const core::ffi::c_void) -> bool,
    end_main_bar: unsafe extern "C" fn(data: *const core::ffi::c_void),
    begin: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        label: FlString,
        enabled: bool,
    ) -> bool,
    end: unsafe extern "C" fn(data: *const core::ffi::c_void),
    item: unsafe extern "C" fn(data: *const core::ffi::c_void, label: FlString) -> bool,
    item_ex: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        label: FlString,
        shortcut: FlString,
        selected: bool,
        enabled: bool,
    ) -> bool,
    item_toggle: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        label: FlString,
        shortcut: FlString,
        selected: *mut bool,
        enabled: bool,
    ) -> bool,
}

#[repr(C)]
#[derive(Debug)]
pub struct Menu {
    _dummy: u32,
}

#[repr(C)]
pub struct MenuApi {
    pub api: *const MenuFfiApi,
}

impl MenuApi {
    /// Append to menu-bar of current window (requires [WindowFlags::MENU_BAR] flag set on parent window).
    pub fn begin_bar(&self) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.begin_bar)(_api.data);
            ret_val
        }
    }

    /// only call end_bar() if begin_bar() returns true!
    pub fn end_bar(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.end_bar)(_api.data);
        }
    }

    /// create and append to a full screen menu-bar.
    pub fn begin_main_bar(&self) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.begin_main_bar)(_api.data);
            ret_val
        }
    }

    /// only call end_main_bar() if begin_main_bar() returns true!
    pub fn end_main_bar(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.end_main_bar)(_api.data);
        }
    }

    /// create a sub-menu entry. only call EndMenu() if this returns true!
    pub fn begin(&self, label: &str, enabled: bool) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.begin)(_api.data, FlString::new(label), enabled);
            ret_val
        }
    }

    /// only call end_menu() if begin_menu() returns true!
    pub fn end(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.end)(_api.data);
        }
    }

    /// return true when activated.
    pub fn item(&self, label: &str) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.item)(_api.data, FlString::new(label));
            ret_val
        }
    }

    /// return true when activated. Includes some extra info such as shortcut, etc
    pub fn item_ex(&self, label: &str, shortcut: &str, selected: bool, enabled: bool) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.item_ex)(
                _api.data,
                FlString::new(label),
                FlString::new(shortcut),
                selected,
                enabled,
            );
            ret_val
        }
    }

    /// return true when activated + toggle selected
    pub fn item_toggle(
        &self,
        label: &str,
        shortcut: &str,
        selected: &mut bool,
        enabled: bool,
    ) -> bool {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.item_toggle)(
                _api.data,
                FlString::new(label),
                FlString::new(shortcut),
                selected as _,
                enabled,
            );
            ret_val
        }
    }
}
