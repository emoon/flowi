// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::*;

extern "C" {
    fn fl_image_create_from_file_impl(ctx: *const core::ffi::c_void, filename: FlString) -> Image;
    fn fl_image_create_from_memory_impl(
        ctx: *const core::ffi::c_void,
        name: FlString,
        data: *const u8,
        data_size: u32,
    ) -> Image;
    fn fl_image_get_info_impl(self_c: Image) -> *const ImageInfo;
    fn fl_image_destroy_impl(self_c: Image);
}

#[repr(C)]
pub struct ImageInfo {
    /// width of the image
    width: u32,
    /// height of the Image
    height: u32,
}

#[derive(Clone, Debug)]
pub struct Image {
    handle: u64,
}

impl Ui {
    /// Load image from file. Supported formats are:
    /// JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
    /// PNG 1/2/4/8/16-bit-per-channel
    /// TGA
    /// BMP non-1bpp, non-RLE
    /// PSD (composited view only, no extra channels, 8/16 bit-per-channel)
    /// GIF
    /// HDR (radiance rgbE format)
    /// PIC (Softimage PIC)
    /// PNM (PPM and PGM binary only)
    pub fn image_create_from_file(&self, filename: &str) -> Option<Image> {
        unsafe {
            let ret_val = fl_image_create_from_file_impl(self.ctx, FlString::new(filename));
            if ret_val == 0 {
                None
            } else {
                Some(Image { handle: ret_value })
            }
        }
    }

    /// Load image from memory. Supported formats are:
    /// JPEG baseline & progressive (12 bpc/arithmetic not supported, same as stock IJG lib)
    /// PNG 1/2/4/8/16-bit-per-channel
    /// TGA
    /// BMP non-1bpp, non-RLE
    /// PSD (composited view only, no extra channels, 8/16 bit-per-channel)
    /// GIF
    /// HDR (radiance rgbE format)
    /// PIC (Softimage PIC)
    /// PNM (PPM and PGM binary only)
    pub fn image_create_from_memory(&self, name: &str, data: &[u8]) -> Option<Image> {
        unsafe {
            let ret_val =
                fl_image_create_from_memory_impl(self.ctx, FlString::new(name), data.as_ptr());
            if ret_val == 0 {
                None
            } else {
                Some(Image { handle: ret_value })
            }
        }
    }
}

impl Image {
    /// Get data amout the image
    pub fn get_info(&self) -> Option<ImageInfo> {
        unsafe {
            let ret_val = fl_image_get_info_impl(self.handle);
            ret_val.as_ref()
        }
    }

    /// Destroy the created image
    pub fn destroy(&self) {
        unsafe {
            fl_image_destroy_impl(self.handle);
        }
    }
}
