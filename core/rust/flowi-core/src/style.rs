// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::*;

extern "C" {
    fn fl_style_create_impl(ctx: *const core::ffi::c_void, name: FlString) -> *mut Style;
    fn fl_style_get_default_impl(ctx: *const core::ffi::c_void) -> *mut Style;
    fn fl_style_get_current_impl(ctx: *const core::ffi::c_void) -> Style;
    fn fl_style_end_changes_impl(ctx: *const core::ffi::c_void, style: *mut Style);
    fn fl_style_push_impl(ctx: *const core::ffi::c_void, style: *mut Style);
    fn fl_style_pop_impl(ctx: *const core::ffi::c_void);
}

#[repr(C)]
#[derive(Debug)]
pub enum LengthPercent {
    Length = 0,
    Percent = 1,
}

#[repr(C)]
#[derive(Debug)]
pub enum Corner {
    TopLeft = 0,
    TopRight = 1,
    BottomLeft = 2,
    BottomRight = 3,
}

#[repr(C)]
#[derive(Debug)]
pub struct LengthPercentValue {
    pub value: f32,
    pub typ: LengthPercent,
}

#[repr(C)]
#[derive(Debug)]
pub struct Border {
    pub radius: [LengthPercentValue; 4],
    pub colors: [u32; 4],
    pub active: bool,
}

#[repr(C)]
#[derive(Debug)]
pub struct Style {
    pub name: FlString,
    pub border: Border,
    pub margin: [u16; 4],
    pub padding: [u16; 4],
    pub current_font: u32,
    pub background_color: u32,
    pub font: Font,
    pub font_size: u32,
    pub text_color: u32,
    pub font_color: u32,
}

impl Context {
    /// Create a new style
    pub fn style_create<'a>(&self, name: &str) -> Result<&'a mut Style> {
        unsafe {
            let self_ = std::mem::transmute(self);
            let ret_val = fl_style_create_impl(self_, FlString::new(name));
            if ret_val.is_null() {
                Err(get_last_error())
            } else {
                Ok(&mut *ret_val)
            }
        }
    }

    /// Get the default style. Changing this will apply the base style for the whole application
    pub fn style_get_default<'a>(&self) -> Result<&'a mut Style> {
        unsafe {
            let self_ = std::mem::transmute(self);
            let ret_val = fl_style_get_default_impl(self_);
            if ret_val.is_null() {
                Err(get_last_error())
            } else {
                Ok(&mut *ret_val)
            }
        }
    }

    /// Get the current style which is based on what has been pushed on the style stack using push/pop
    pub fn style_get_current(&self) -> Style {
        unsafe {
            let self_ = std::mem::transmute(self);
            let ret_val = fl_style_get_current_impl(self_);
            ret_val
        }
    }

    /// Mark the end of style changes
    pub fn style_end_changes(&self, style: &mut Style) {
        unsafe {
            let self_ = std::mem::transmute(self);
            fl_style_end_changes_impl(self_, style as _);
        }
    }

    /// Select the style to be used, to end using the style use 'fl_pop_style()'
    pub fn style_push(&self, style: &mut Style) {
        unsafe {
            let self_ = std::mem::transmute(self);
            fl_style_push_impl(self_, style as _);
        }
    }

    /// Pops the current style
    pub fn style_pop(&self) {
        unsafe {
            let self_ = std::mem::transmute(self);
            fl_style_pop_impl(self_);
        }
    }
}
