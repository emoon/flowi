// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::*;

extern "C" {
    fn fl_style_create_impl(ctx: *const core::ffi::c_void, name: FlString) -> *mut Style;
    fn fl_style_get_default_impl(ctx: *const core::ffi::c_void) -> *mut Style;
    fn fl_style_get_current_impl(ctx: *const core::ffi::c_void) -> *const Style;
    fn fl_style_end_changes_impl(self_c: *mut Style);
    fn fl_style_push_impl(self_c: *mut Style);
    fn fl_style_pop_impl(self_c: *mut Style);
}

#[repr(C)]
#[derive(Debug)]
pub enum LengthPercent {
    Length = 0,
    Percent = 1,
}

#[repr(C)]
#[derive(Debug)]
pub struct LengthPercentValue {
    value: f32,
    typ: LengthPercent,
}

#[repr(C)]
#[derive(Debug)]
pub struct Spacing {
    top: u16,
    right: u16,
    bottom: u16,
    left: u16,
}

#[repr(C)]
#[derive(Debug)]
pub struct Padding {
    top: u16,
    right: u16,
    bottom: u16,
    left: u16,
}

#[repr(C)]
#[derive(Debug)]
pub struct Border {
    border_radius_top: LengthPercentValue,
    border_radius_right: LengthPercentValue,
    border_radius_bottom: LengthPercentValue,
    border_radius_left: LengthPercentValue,
}

#[repr(C)]
#[derive(Debug)]
pub struct Style {
    name: FlString,
    border: Border,
    padding: Padding,
    current_font: u32,
    background_color: Color,
    text_color: Color,
    font_color: Color,
}

impl Context {
    /// Create a new style
    pub fn style_create(&self, name: &str) -> Result<&mut Style> {
        unsafe {
            let self_ = std::mem::transmute(self);
            let ret_val = fl_style_create_impl(self_, FlString::new(name));
            if ret_val.is_null() {
                Err(get_last_error())
            } else {
                Ok(&mut *ret_val)
            }
        }
    }

    /// Get the default style. Changing this will apply the base style for the whole application
    pub fn style_get_default(&self) -> Result<&mut Style> {
        unsafe {
            let self_ = std::mem::transmute(self);
            let ret_val = fl_style_get_default_impl(self_);
            if ret_val.is_null() {
                Err(get_last_error())
            } else {
                Ok(&mut *ret_val)
            }
        }
    }

    /// Get the current style which is based on what has been pushed on the style stack using push/pop
    pub fn style_get_current(&self) -> Result<&Style> {
        unsafe {
            let self_ = std::mem::transmute(self);
            let ret_val = fl_style_get_current_impl(self_);
            if ret_val.is_null() {
                Err(get_last_error())
            } else {
                Ok(&*ret_val)
            }
        }
    }
}

impl Style {
    /// Mark the end of style changes
    pub fn end_changes(&self) {
        unsafe {
            let self_ = std::mem::transmute(self);
            fl_style_end_changes_impl(self_);
        }
    }

    /// Select the style to be used, to end using the style use 'fl_pop_style()'
    pub fn push(&self) {
        unsafe {
            let self_ = std::mem::transmute(self);
            fl_style_push_impl(self_);
        }
    }

    /// Pops the current style
    pub fn pop(&self) {
        unsafe {
            let self_ = std::mem::transmute(self);
            fl_style_pop_impl(self_);
        }
    }
}
