
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// This file is auto-generated by api_gen. DO NOT EDIT!
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#pragma once

#include <stdbool.h>
#include <stdint.h>
#include <string.h>
#include "context.h"
#include "idx.h"
#include "manual.h"

#ifdef __cplusplus
extern "C" {
#endif

// Allows the user to select how accurate the glyph placement should be.
// The list has a the fastest (CPU performance wise) first (Monospace) and the slowest (Accurate) last
// Rule of thumb is:
// Auto (Same as basic)
// Monospaced (code/fixed size fonts) - use Monospace mode
// Regular Latin text - use Basic mode
// Hebrew and other complex languages that require accurate layout - Use accurate
typedef enum FlFontPlacementMode {
    // Let the library decide the mode (default)
    FlFontPlacementMode_Auto = 0,
    // Used for regular Latin based text
    FlFontPlacementMode_Basic = 1,
    // Used for fixed-width monospaces fonts (Fastest)
    FlFontPlacementMode_Mono = 2,
    // Used for accurate glyph placement (uses the Harfbuzz lib thus is the slowest mode)
    FlFontPlacementMode_Accurate = 3,
} FlFontPlacementMode;

typedef uint64_t FlFont;

// Create a font from (TTF) file. To use the font use [Font::set] or [Font::set_with_size] before using text-based
// widgets Returns >= 0 for valid handle, use fl_get_status(); for more detailed error message
FlFont fl_font_new_from_file_impl(struct FlContext* ctx, FlString filename, uint32_t font_size,
                                  FlFontPlacementMode placement_mode);

FL_INLINE FlFont fl_font_new_from_file(struct FlContext* ctx, const char* filename, uint32_t font_size,
                                       FlFontPlacementMode placement_mode) {
    FlString filename_ = fl_cstr_to_flstring(filename);
    return fl_font_new_from_file_impl(ctx, filename_, font_size, placement_mode);
}

// Create a font from memory. Data is expected to point to a TTF file. Fl will take a copy of this data in some cases
// Like when needing the accurate placement mode used by Harzbuff that needs to original ttf data
FlFont fl_font_new_from_memory_impl(struct FlContext* ctx, FlString name, uint8_t* data, uint32_t data_size,
                                    uint32_t font_size, FlFontPlacementMode placement_mode);

FL_INLINE FlFont fl_font_new_from_memory(struct FlContext* ctx, const char* name, uint8_t* data, uint32_t data_size,
                                         uint32_t font_size, FlFontPlacementMode placement_mode) {
    FlString name_ = fl_cstr_to_flstring(name);
    return fl_font_new_from_memory_impl(ctx, name_, data, data_size, font_size, placement_mode);
}

// Set the font as active when drawing text
void fl_font_set_impl(struct FlContext* ctx, FlFont font);

FL_INLINE void fl_font_set(struct FlContext* ctx, FlFont font) {
    fl_font_set_impl(ctx, font);
}

// Set font active with specific size in pixels
void fl_font_set_with_size_impl(struct FlContext* ctx, uint32_t size);

FL_INLINE void fl_font_set_with_size(struct FlContext* ctx, uint32_t size) {
    fl_font_set_with_size_impl(ctx, size);
}

// Destory the current font, render the id invalid
void fl_font_destroy_impl(struct FlContext* ctx, FlFont font);

FL_INLINE void fl_font_destroy(struct FlContext* ctx, FlFont font) {
    fl_font_destroy_impl(ctx, font);
}

#ifdef __cplusplus
}
#endif
