// This file is auto-generated by api_gen. DO NOT EDIT!

#[allow(unused_imports)]
use crate::manual::{get_last_error, Color, FlString, Result};

#[allow(unused_imports)]
use bitflags::bitflags;

#[allow(unused_imports)]
use crate::math_data::*;

#[repr(C)]
pub struct CursorFfiApi {
    pub(crate) data: *const core::ffi::c_void,
    separator: unsafe extern "C" fn(data: *const core::ffi::c_void),
    same_line: unsafe extern "C" fn(
        data: *const core::ffi::c_void,
        offset_from_start_x: f32,
        spacing: f32,
    ),
    new_line: unsafe extern "C" fn(data: *const core::ffi::c_void),
    spacing: unsafe extern "C" fn(data: *const core::ffi::c_void),
    dummy: unsafe extern "C" fn(data: *const core::ffi::c_void, size: Vec2),
    indent: unsafe extern "C" fn(data: *const core::ffi::c_void, indent: f32),
    unindent: unsafe extern "C" fn(data: *const core::ffi::c_void, indent_w: f32),
    begin_group: unsafe extern "C" fn(data: *const core::ffi::c_void),
    end_group: unsafe extern "C" fn(data: *const core::ffi::c_void),
    get_pos: unsafe extern "C" fn(data: *const core::ffi::c_void) -> Vec2,
    get_pos_x: unsafe extern "C" fn(data: *const core::ffi::c_void) -> f32,
    get_pos_y: unsafe extern "C" fn(data: *const core::ffi::c_void) -> f32,
    set_pos: unsafe extern "C" fn(data: *const core::ffi::c_void, pos: Vec2),
    set_pos_x: unsafe extern "C" fn(data: *const core::ffi::c_void, x: f32),
    set_pos_y: unsafe extern "C" fn(data: *const core::ffi::c_void, y: f32),
    screen_pos: unsafe extern "C" fn(data: *const core::ffi::c_void) -> Vec2,
    set_screen_pos: unsafe extern "C" fn(data: *const core::ffi::c_void, pos: Vec2),
    align_text_to_frame_padding: unsafe extern "C" fn(data: *const core::ffi::c_void),
    get_text_line_height: unsafe extern "C" fn(data: *const core::ffi::c_void) -> f32,
    get_text_line_height_with_spacing: unsafe extern "C" fn(data: *const core::ffi::c_void) -> f32,
    get_frame_height: unsafe extern "C" fn(data: *const core::ffi::c_void) -> f32,
    get_frame_height_with_spacing: unsafe extern "C" fn(data: *const core::ffi::c_void) -> f32,
}

/// Layout Cursor
/// Cursor means the position of the widget.
/// By setting the cursor position, you can change the position of the widget.
/// You can call same_line() between widgets to undo the last carriage return and output at the right of the preceding widget.
#[repr(C)]
#[derive(Debug)]
pub struct Cursor {
    _dummy: u32,
}

#[repr(C)]
pub struct CursorApi {
    pub api: *const CursorFfiApi,
}

impl CursorApi {
    /// Separator, generally horizontal. Inside a menu bar or in horizontal layout mode, this becomes a vertical separator.
    pub fn separator(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.separator)(_api.data);
        }
    }

    /// Call between widgets or groups to layout them horizontally. X position given in window coordinates.
    pub fn same_line(&self, offset_from_start_x: f32, spacing: f32) {
        unsafe {
            let _api = &*self.api;
            (_api.same_line)(_api.data, offset_from_start_x, spacing);
        }
    }

    /// Undo a same_line() or force a new line when in a horizontal-layout context.
    pub fn new_line(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.new_line)(_api.data);
        }
    }

    /// Undo a same_line() or force a new line when in a horizontal-layout context.
    pub fn spacing(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.spacing)(_api.data);
        }
    }

    /// Add a dummy item of given size. Unlike widgets.invisible_button(), dummmy() won't take the mouse click or be navigable into.
    pub fn dummy(&self, size: Vec2) {
        unsafe {
            let _api = &*self.api;
            (_api.dummy)(_api.data, size);
        }
    }

    /// Move content position toward the right, by indent_w, or style.IndentSpacing if indent_w <= 0
    pub fn indent(&self, indent: f32) {
        unsafe {
            let _api = &*self.api;
            (_api.indent)(_api.data, indent);
        }
    }

    /// Move content position back to the left, by indent_w, or style.IndentSpacing if indent_w <= 0
    pub fn unindent(&self, indent_w: f32) {
        unsafe {
            let _api = &*self.api;
            (_api.unindent)(_api.data, indent_w);
        }
    }

    pub fn begin_group(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.begin_group)(_api.data);
        }
    }

    pub fn end_group(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.end_group)(_api.data);
        }
    }

    /// Cursor position in window coordinates (relative to window position)
    pub fn get_pos(&self) -> Vec2 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_pos)(_api.data);
            ret_val
        }
    }

    pub fn get_pos_x(&self) -> f32 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_pos_x)(_api.data);
            ret_val
        }
    }

    pub fn get_pos_y(&self) -> f32 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_pos_y)(_api.data);
            ret_val
        }
    }

    /// Set position in window coordinates (relative to window position)
    pub fn set_pos(&self, pos: Vec2) {
        unsafe {
            let _api = &*self.api;
            (_api.set_pos)(_api.data, pos);
        }
    }

    pub fn set_pos_x(&self, x: f32) {
        unsafe {
            let _api = &*self.api;
            (_api.set_pos_x)(_api.data, x);
        }
    }

    pub fn set_pos_y(&self, y: f32) {
        unsafe {
            let _api = &*self.api;
            (_api.set_pos_y)(_api.data, y);
        }
    }

    /// cursor position in absolute coordinates (useful to work with ImDrawList API).
    /// generally top-left == GetMainViewport()->Pos == (0,0) in single viewport mode,
    /// and bottom-right == GetMainViewport()->Pos+Size == io.DisplaySize in single-viewport mode.
    pub fn screen_pos(&self) -> Vec2 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.screen_pos)(_api.data);
            ret_val
        }
    }

    pub fn set_screen_pos(&self, pos: Vec2) {
        unsafe {
            let _api = &*self.api;
            (_api.set_screen_pos)(_api.data, pos);
        }
    }

    /// vertically align upcoming text baseline to FramePadding.y so that it will align properly to regularly framed items (call if you have text on a line before a framed item)
    pub fn align_text_to_frame_padding(&self) {
        unsafe {
            let _api = &*self.api;
            (_api.align_text_to_frame_padding)(_api.data);
        }
    }

    /// ~ FontSize
    pub fn get_text_line_height(&self) -> f32 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_text_line_height)(_api.data);
            ret_val
        }
    }

    /// ~ FontSize + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of text)
    pub fn get_text_line_height_with_spacing(&self) -> f32 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_text_line_height_with_spacing)(_api.data);
            ret_val
        }
    }

    /// ~ FontSize + style.FramePadding.y * 2
    pub fn get_frame_height(&self) -> f32 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_frame_height)(_api.data);
            ret_val
        }
    }

    /// ~ FontSize + style.FramePadding.y * 2 + style.ItemSpacing.y (distance in pixels between 2 consecutive lines of framed widgets)
    pub fn get_frame_height_with_spacing(&self) -> f32 {
        unsafe {
            let _api = &*self.api;
            let ret_val = (_api.get_frame_height_with_spacing)(_api.data);
            ret_val
        }
    }
}
